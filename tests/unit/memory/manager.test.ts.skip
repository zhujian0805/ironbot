import { describe, expect, it, vi, beforeEach, afterEach } from "vitest";
import fs from "node:fs";
import path from "node:path";

// Mock bun:sqlite with functional database
class MockDatabase {
  private data: { [table: string]: any[] } = {
    files: [],
    chunks: []
  };

  close = vi.fn();
  exec = vi.fn((sql: string) => {
    // Simple SQL execution simulation
    if (sql.includes("INSERT INTO files")) {
      const match = sql.match(/INSERT INTO files \([^)]+\) VALUES \(([^)]+)\)/);
      if (match) {
        const values = match[1].split(',').map(v => v.trim().replace(/['"]/g, ''));
        this.data.files.push({
          id: this.data.files.length + 1,
          path: values[0],
          source: values[1],
          session_key: values[2] || null,
          updated_at: parseInt(values[3]) || Date.now()
        });
      }
    } else if (sql.includes("INSERT INTO chunks")) {
      const match = sql.match(/INSERT INTO chunks \([^)]+\) VALUES \(([^)]+)\)/);
      if (match) {
        const values = match[1].split(',').map(v => v.trim().replace(/['"]/g, ''));
        this.data.chunks.push({
          id: this.data.chunks.length + 1,
          file_id: parseInt(values[0]),
          chunk_index: parseInt(values[1]),
          content: values[2],
          embedding: values[3] || null,
          embedding_dim: values[4] || null
        });
      }
    }
  });

  prepare = vi.fn((sql: string) => {
    if (sql.includes("SELECT * FROM files")) {
      return {
        all: vi.fn(() => this.data.files),
        run: vi.fn(),
        get: vi.fn()
      };
    } else if (sql.includes("SELECT * FROM chunks")) {
      return {
        all: vi.fn(() => this.data.chunks),
        run: vi.fn(),
        get: vi.fn()
      };
    } else if (sql.includes("SELECT COUNT(*) as count FROM files")) {
      return {
        all: vi.fn(),
        run: vi.fn(),
        get: vi.fn(() => ({ count: this.data.files.length }))
      };
    } else if (sql.includes("SELECT COUNT(*) as count FROM chunks")) {
      return {
        all: vi.fn(),
        run: vi.fn(),
        get: vi.fn(() => ({ count: this.data.chunks.length }))
      };
    } else if (sql.includes("DELETE FROM")) {
      return {
        all: vi.fn(),
        run: vi.fn(() => {
          if (sql.includes("files")) this.data.files = [];
          if (sql.includes("chunks")) this.data.chunks = [];
        }),
        get: vi.fn()
      };
    }
    return {
      all: vi.fn(() => []),
      run: vi.fn(),
      get: vi.fn(() => ({ count: 0 }))
    };
  });
}

vi.mock("bun:sqlite", () => ({
  Database: MockDatabase
}));
import { Database } from "bun:sqlite";
import { MemoryManager } from "../../../src/memory/manager.ts";

// Global mock variables
let mockResolveStateDir: any;
let mockResolveEmbeddingClient: any;
let mockEnsureMemorySchema: any;
let mockLogger: any;

// Mock dependencies
vi.mock("../../../src/sessions/paths.ts", () => ({
  resolveStateDir: (...args: any[]) => mockResolveStateDir(...args)
}));
vi.mock("../../../src/memory/memory_schema.ts", () => ({
  ensureMemorySchema: (...args: any[]) => mockEnsureMemorySchema(...args)
}));
vi.mock("../../../src/memory/embeddings.ts", () => ({
  resolveEmbeddingClient: (...args: any[]) => mockResolveEmbeddingClient(...args)
}));
vi.mock("../../../src/utils/logging.ts", () => ({
  logger: mockLogger
}));
vi.mock("node:fs", () => ({
  default: {
    mkdirSync: vi.fn(),
    promises: {
      mkdir: vi.fn(),
      readdir: vi.fn(),
      readFile: vi.fn(),
      writeFile: vi.fn(),
      stat: vi.fn(),
      access: vi.fn(),
      realpath: vi.fn()
    }
  }
}));

vi.mock("../../../src/sessions/session_key.ts", () => ({
  DEFAULT_AGENT_ID: "test-agent",
  isMainSessionKey: vi.fn(() => false)
}));

vi.mock("../../../src/sessions/transcript_events.ts", () => ({
  onTranscriptAppended: vi.fn()
}));

// Initialize global mocks
beforeAll(() => {
  mockResolveStateDir = vi.fn(() => "/tmp/state");
  mockResolveEmbeddingClient = vi.fn(() => ({
    provider: "none",
    model: "",
    embed: vi.fn(() => [])
  }));
  mockEnsureMemorySchema = vi.fn();
  mockLogger = {
    info: vi.fn(),
    warn: vi.fn(),
    error: vi.fn(),
    debug: vi.fn()
  };
});

describe.skip("MemoryManager", () => {
  let tempDir: string;
  let db: Database;

  beforeEach(() => {
    tempDir = `/tmp/memory-test-${Date.now()}`;
    vi.clearAllMocks();

    // Mock fs operations
    vi.mocked(fs).mkdirSync.mockImplementation(() => undefined);
    vi.mocked(fs.promises).mkdir.mockResolvedValue(undefined);
    vi.mocked(fs.promises).readdir.mockResolvedValue([]);
    vi.mocked(fs.promises).readFile.mockResolvedValue("");
    vi.mocked(fs.promises).stat.mockResolvedValue({
      mtimeMs: Date.now(),
      isDirectory: () => false,
      isFile: () => true
    } as any);
    vi.mocked(fs.promises).access.mockResolvedValue(undefined);
    vi.mocked(fs.promises).realpath.mockImplementation((p) => Promise.resolve(p));

    // Create in-memory database for testing
    db = new Database(":memory:");
  });

  afterEach(() => {
    db.close();
  });

  describe("constructor", () => {
    it("initializes with correct configuration", () => {
      const config = {
        memory: {
          workspaceDir: "/workspace",
          sessionIndexing: true
        },
        memorySearch: {
          enabled: true,
          sources: ["memory", "sessions"],
          storePath: undefined,
          vectorWeight: 0.7,
          textWeight: 0.3,
          candidateMultiplier: 2,
          maxResults: 10,
          minScore: 0.1,
          crossSessionMemory: false
        },
        sessions: {
          storePath: "/tmp/sessions",
          transcriptsDir: "/tmp/transcripts",
          dmSessionKey: "main",
          maxHistoryMessages: 10
        },
        embeddings: {
          provider: "none",
          fallback: "none"
        }
      } as any;

      const manager = new MemoryManager(config);

      expect(manager).toBeDefined();
      expect(mockResolveStateDir).toHaveBeenCalled();
      expect(mockResolveEmbeddingClient).toHaveBeenCalledWith(config.embeddings);
      expect(mockEnsureMemorySchema).toHaveBeenCalled();
    });

    it("creates database file in correct location", () => {
      const config = {
        memory: { workspaceDir: "/workspace", sessionIndexing: false },
        memorySearch: { enabled: true, sources: ["memory"], storePath: undefined, vectorWeight: 0.5, textWeight: 0.5, candidateMultiplier: 2, maxResults: 10, minScore: 0, crossSessionMemory: false },
        sessions: { storePath: "/tmp/sessions", transcriptsDir: "/tmp/transcripts", dmSessionKey: "main", maxHistoryMessages: 10 },
        embeddings: { provider: "none", fallback: "none" }
      } as any;

      new MemoryManager(config, "test-agent");

      expect(fs.mkdirSync).toHaveBeenCalledWith(path.dirname(path.join("/tmp/state", "memory", "test-agent.sqlite")), { recursive: true });
    });
  });

  describe("search", () => {
    let manager: MemoryManager;

    beforeEach(() => {
      const config = {
        memory: { workspaceDir: "/workspace", sessionIndexing: false },
        memorySearch: {
          enabled: true,
          sources: ["memory"],
          storePath: undefined,
          vectorWeight: 0,
          textWeight: 1,
          candidateMultiplier: 2,
          maxResults: 10,
          minScore: 0,
          crossSessionMemory: false
        },
        sessions: { storePath: "/tmp/sessions", transcriptsDir: "/tmp/transcripts", dmSessionKey: "main", maxHistoryMessages: 10 },
        embeddings: { provider: "none", fallback: "none" }
      } as any;

      manager = new MemoryManager(config);
      // Replace the database with our test one
      (manager as any).db = db;
    });

    it("returns empty array when search is disabled", async () => {
      const config = {
        memory: { workspaceDir: "/workspace", sessionIndexing: false },
        memorySearch: { enabled: false, sources: [], storePath: undefined, vectorWeight: 0, textWeight: 0, candidateMultiplier: 1, maxResults: 1, minScore: 0, crossSessionMemory: false },
        sessions: { storePath: "/tmp/sessions", transcriptsDir: "/tmp/transcripts", dmSessionKey: "main", maxHistoryMessages: 10 },
        embeddings: { provider: "none", fallback: "none" }
      } as any;

      const disabledManager = new MemoryManager(config);
      (disabledManager as any).db = db;

      const results = await disabledManager.search("test");

      expect(results).toEqual([]);
    });

    it("searches memory files", async () => {
      // Insert test data
      db.exec(`
        INSERT INTO files (path, source, updated_at) VALUES ('/test/file.md', 'memory', ${Date.now()});
        INSERT INTO chunks (file_id, chunk_index, content, embedding, embedding_dim)
        VALUES (1, 0, 'This is a test document about testing', NULL, NULL);
      `);

      const results = await manager.search("test");

      expect(results.length).toBeGreaterThan(0);
      expect(results[0].snippet).toContain("test");
      expect(results[0].path).toBe("/test/file.md");
      expect(results[0].source).toBe("memory");
    });

    it("filters results by session key", async () => {
      // Insert test data with session key
      db.exec(`
        INSERT INTO files (path, source, session_key, updated_at) VALUES ('/test/session.md', 'sessions', 'session-1', ${Date.now()});
        INSERT INTO chunks (file_id, chunk_index, content, embedding, embedding_dim)
        VALUES (1, 0, 'Session specific content', NULL, NULL);
      `);

      const results = await manager.search("content", { sessionKey: "session-1" });

      expect(results.length).toBeGreaterThan(0);
      expect(results[0].path).toBe("/test/session.md");
      expect(results[0].source).toBe("sessions");
    });
  });

  describe("recordTranscriptMessage", () => {
    let manager: MemoryManager;

    beforeEach(() => {
      const config = {
        memory: { workspaceDir: "/workspace", sessionIndexing: true },
        memorySearch: {
          enabled: true,
          sources: ["sessions"],
          storePath: undefined,
          vectorWeight: 0,
          textWeight: 1,
          candidateMultiplier: 2,
          maxResults: 10,
          minScore: 0,
          crossSessionMemory: false
        },
        sessions: { storePath: "/tmp/sessions", transcriptsDir: "/tmp/transcripts", dmSessionKey: "main", maxHistoryMessages: 10 },
        embeddings: { provider: "none", fallback: "none" }
      } as any;

      manager = new MemoryManager(config);
      (manager as any).db = db;
    });

    it("records transcript message", async () => {
      await manager.recordTranscriptMessage({
        sessionKey: "test-session",
        sessionFile: "/transcripts/test.jsonl",
        content: "User asked about testing"
      });

      const files = db.prepare("SELECT * FROM files").all();
      const chunks = db.prepare("SELECT * FROM chunks").all();

      expect(files.length).toBe(1);
      expect(files[0].session_key).toBe("test-session");
      expect(chunks.length).toBe(1);
      expect(chunks[0].content).toBe("User asked about testing");
    });

    it("skips recording when session indexing disabled", async () => {
      const config = {
        memory: { workspaceDir: "/workspace", sessionIndexing: false },
        memorySearch: { enabled: true, sources: ["sessions"], storePath: undefined, vectorWeight: 0, textWeight: 1, candidateMultiplier: 2, maxResults: 10, minScore: 0, crossSessionMemory: false },
        sessions: { storePath: "/tmp/sessions", transcriptsDir: "/tmp/transcripts", dmSessionKey: "main", maxHistoryMessages: 10 },
        embeddings: { provider: "none", fallback: "none" }
      } as any;

      const disabledManager = new MemoryManager(config);
      (disabledManager as any).db = db;

      await disabledManager.recordTranscriptMessage({
        sessionKey: "test-session",
        sessionFile: "/transcripts/test.jsonl",
        content: "Should not be recorded"
      });

      const files = db.prepare("SELECT * FROM files").all();
      expect(files.length).toBe(0);
    });

    it("skips empty content", async () => {
      await manager.recordTranscriptMessage({
        sessionKey: "test-session",
        sessionFile: "/transcripts/test.jsonl",
        content: ""
      });

      const files = db.prepare("SELECT * FROM files").all();
      expect(files.length).toBe(0);
    });
  });

  describe("clearAllMemory", () => {
    it("clears all chunks and files from database", async () => {
      const config = {
        memory: { workspaceDir: "/workspace", sessionIndexing: true },
        memorySearch: { enabled: true, sources: ["memory"], storePath: undefined, vectorWeight: 0.5, textWeight: 0.5, candidateMultiplier: 2, maxResults: 10, minScore: 0, crossSessionMemory: false },
        sessions: { storePath: "/tmp/sessions", transcriptsDir: "/tmp/transcripts", dmSessionKey: "main", maxHistoryMessages: 10 },
        embeddings: { provider: "none", fallback: "none" }
      } as any;

      const db = new Database(":memory:");
      const manager = new MemoryManager(config);
      (manager as any).db = db;

      // Insert some test data
      db.prepare("INSERT INTO files (path, source, session_key) VALUES (?, ?, ?)").run("/test1.jsonl", "sessions", "session1");
      db.prepare("INSERT INTO files (path, source, session_key) VALUES (?, ?, ?)").run("/test2.jsonl", "sessions", "session2");
      db.prepare("INSERT INTO chunks (file_id, content, embedding) VALUES (?, ?, ?)").run(1, "test content 1", "[1,2,3]");
      db.prepare("INSERT INTO chunks (file_id, content, embedding) VALUES (?, ?, ?)").run(2, "test content 2", "[4,5,6]");

      // Verify data exists
      let files = db.prepare("SELECT COUNT(*) as count FROM files").get();
      let chunks = db.prepare("SELECT COUNT(*) as count FROM chunks").get();
      expect(files.count).toBe(2);
      expect(chunks.count).toBe(2);

      // Clear all memory
      await manager.clearAllMemory();

      // Verify data is cleared
      files = db.prepare("SELECT COUNT(*) as count FROM files").get();
      chunks = db.prepare("SELECT COUNT(*) as count FROM chunks").get();
      expect(files.count).toBe(0);
      expect(chunks.count).toBe(0);

      db.close();
    });
  });

  describe("logStatus", () => {
    it("logs memory manager status", () => {
      const config = {
        memory: { workspaceDir: "/workspace", sessionIndexing: true },
        memorySearch: { enabled: true, sources: ["memory"], storePath: undefined, vectorWeight: 0.5, textWeight: 0.5, candidateMultiplier: 2, maxResults: 10, minScore: 0, crossSessionMemory: false },
        sessions: { storePath: "/tmp/sessions", transcriptsDir: "/tmp/transcripts", dmSessionKey: "main", maxHistoryMessages: 10 },
        embeddings: { provider: "none", fallback: "none" }
      } as any;

      const manager = new MemoryManager(config);
      manager.logStatus();

      expect(mockLogger.info).toHaveBeenCalledWith(
        expect.objectContaining({
          provider: "none",
          model: "",
          memorySearchEnabled: true,
          sessionIndexing: true
        }),
        "Memory manager initialized"
      );
    });
  });
});
